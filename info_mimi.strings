/* 
  info_mimi.strings
  minishell_xcd

  Created by Julia Demura on 15/07/2022.
  
*/

TEST

#BUILTIN echo
//echo
//echo -n
//echo -nnnnnnnnnnn
//echo -n -n
//echo -nf -n
//echo -n -nf
//echo test -n
//echo -n test
//echo test -n -n
//echo -n -n test
//echo -n test -n
//echo testOne testTwo testThree
//echo $PWD
//echo $OLDPWD
echo ''


#BUILTIN cd
//cd
//cd NOT_EXISTING_DIR


'//cd NOT_EXISTING_FILE - ??
'//cd LICENSE		-??
//cd ..
//cd includes/../srcs

#BUILTIN exit
exit
exit 255
exit 10000
exit bla 24
exit 24 bla
exit bla bla
exit bla bla bla
exit 1 2 3
exit -3
exit -3 7





#BUILTIN env
//env | grep --invert-match | sort
//env

#BUILTIN pwd
//pwd
//pwd bla
//pwd 1
//pwd bla bla



#BUILTIN unset
//unset USER
//unset BLA
//unset bla
//unset PATH1
//unset 1PATH !!!!!!! err
//unset PATH USER
//unset PATH USER LOGNAME
//unset _PATH
//unset PATH_


#BUILTIN export
//export | grep --invert-match 'declare -x _='

#QUOTES single quote
//echo 'hello there'
//echo '"hello there"'
//echo ''hello''
//echo '$PWD'
//echo 'I am a pipe | and I am a redirect > < << >>'



#QUOTES double quote
echo "hello there"
echo "'hello there'"
echo ""hello""
echo "$PWD"
echo "I am a pipe | and I am a redirect > < << >>"
#REDIRECT input
< Makefile
cat < Makefile
cat < LICENSE < Makefile
cat < Dockerfile < LICENSE < Makefile
#REDIRECT output
>OUT;cat OUT;rm OUT
ls -la > OUT;cat OUT;rm OUT
cat < Makefile > OUT; cat OUT;rm OUT
ls -la > OUT1 > OUT2;ls;cat OUT1;cat OUT2;rm OUT1 OUT2
ls -la > OUT1 > OUT2 > OUT3;ls;cat OUT1;cat OUT2;cat OUT3;rm OUT1 OUT2 OUT3




#REDIRECT append
>>OUT;cat OUT;rm OUT
ls -la >> OUT;cat OUT;rm OUT
cat < Makefile >> OUT; cat OUT;rm OUT
ls -la >> OUT1 >> OUT2;ls;cat OUT1;cat OUT2;rm OUT1 OUT2
ls -la >> OUT1 >> OUT2 >> OUT3;ls;cat OUT1;cat OUT2;cat OUT3;rm OUT1 OUT2 OUT3
echo one >> OUT;echo two >> OUT;echo tree >> OUT;cat OUT;rm OUT



#REDIRECT heredoc
#PIPES
ls -l | wc -l
echo "bla di bla" | wc -l
echo "bla di bla" | grep "bla" | wc -l
env | ls -l | wc -l
echo cat | wc -l | cat
pwd | cat | env | sort
echo one | cat -e | cat -e | grep one
ls -l | wc -l | echo cat
ls -l | wc -l | echo cat | wc -l
pwd | wc -l | echo cat | wc -l
ls -l | head -n 6 | tail -n 5 | head -n 4 | tail -n 3 | head -n 2 | wc -l




#PARSER spaces
echo one  two   three    four
cat<Makefile|grep NAME>OUT;cat OUT;rm OUT
#PARSER word splitting
cat Make'file'
cat 'Make'file
cat Make"file"
cat "Make"file
cat "Make"'file'
cat 'Make'"file"
cat $HOME"/.bashrc"
ls "$HOME"'/../'$USER
echo $USER$PWD
#PARSER normalization / word order
< Makefile cat
< LICENSE < Dockerfile < Makefile cat -e
cat < Dockerfile < LICENSE < Makefile -e
< LICENSE cat -e < Makefile
> OUT cat -e < Makefile;cat OUT;rm OUT
< Makefile grep NAME > OUT;cat OUT;rm OUT
#PATHRESOLVE
ls
/bin/ls
/bin/../bin/ls
/usr/bin/../../bin/ls
cd /bin;./ls
cd /;bin/ls
#ENVIRONMENT variables
echo $
echo $USER
echo "$USER"
echo "$USER $PWD $HOME"
echo;echo $?
echo one | grep -q two;echo $?
#EVAL
/bin/ls
touch DANG;chmod u-r DANG;cat DANG;rm DANG
/bin/ls -l
echo Hi
echo -n Hi
exit
exit 42
exit -3
exit bla
/bin/ls -l
echo;echo $?
/bin/ls filethatdoesntexist
echo;echo $?
expr $? + $?
echo "bla bla"
echo "cat lol.c | cat > lol.c"
echo ''
echo 'bla'
exit '42'
echo 'env'
echo 'ls -l | wc -l'
echo '$USER'
env | sort
export NEW_VAR;export | grep "NEW_VAR"
env | grep USER=;unset USER;env | grep USER=
cd tests
cd tests;pwd
cd .;pwd
cd ..;pwd
pwd
unset PATH
export PATH=directory1:directory2
cat < Makefile
< Makefile cat
ls -la > OUT1
ls -la > OUT1 > OUT1;rm OUT1
ls -la > OUT1 > OUT2;rm OUT1;rm OUT2
< Makefile cat > OUT1;rm OUT1
< OUT1 ls -la >> OUT1
dsbksdgbksdghsd
echo $PATH
echo "$PATH"
echo $USER
echo "$USER"





















tutorial on altering scripts// https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux

bubble sort //https://pencilprogrammer.com/algorithms/bubble-sort/ - bubble alg


"exit"


After exit(), the exit status must be transmitted to the parent
	   process.  There are three cases:

	   •  If the parent has set SA_NOCLDWAIT, or has set the SIGCHLD
		  handler to SIG_IGN, the status is discarded and the child dies
		  immediately.

	   •  If the parent was waiting on the child, it is notified of the
		  exit status and the child dies immediately.

	   •  Otherwise, the child becomes a "zombie" process: most of the
		  process resources are recycled, but a slot containing minimal
		  information about the child process (termination status,
		  resource usage statistics) is retained in process table.  This
		  allows the parent to subsequently use waitpid(2) (or similar)
		  to learn the termination status of the child; at that point
		  the zombie process slot is released.

	   If the implementation supports the SIGCHLD signal, this signal is
	   sent to the parent.  If the parent has set SA_NOCLDWAIT, it is
	   undefined whether a SIGCHLD signal is sent.




CD exploration

//change folder - cd [absolute/relative path]
// with change of directory also variable

//https://www.ibm.com/docs/en/zos/2.3.0?topic=descriptions-cd-change-working-directory
// env_var to change \
OLDPWD=/Users/ydemura \
\
Calling cd without arguments sets the working directory to the value of the HOME environment variable, if the variable exists. If there is no HOME variable, cd does not change the working directory. \
\

//int chdir(const char *path); On success, zero is returned.  On error, -1 is returned, and errno is set to indicate the error.

"start"
'env:
OLDPWD - none
PWD=/Users/ydemura
HOME=/Users/ydemura



'cd Desktop/ + env
OLDPWD=/Users/ydemura
PWD=/Users/ydemura/Desktop
HOME=/Users/ydemura


HOME - remains same, unchanged



CD with no arguments
goto -> HOME_value
PWD -> HOME_value

OLDPWD
if existed - change to folder before goto
if not existed - now existed

CD



if (no arguments && HOME exists)
{
	if (OLDPWD existed)
		change value to one stored in PWD
	else
		create OLDPWD (try not to malloc) with value of pwd before change pwd
	PWD = HOME
	'activate chdir'(VALUE_OF_HOME) ->> changes the current working directory of the calling process to the directory specified in path.
	VALUE_OF_HOME = HOME string + int number_before=sign+1_for=sign
}

else if (arguments are)
{
	if (OLDPWD existed)
		change value to one stored in PWD
	else if (OLDPWD not existed)
		create OLDPWD (try not to malloc) with value of pwd before change pwd
	'activate chdir'(ARGUMENT) ->> changes the current working directory of the calling process to the directory specified in path.
	anyway I need only 1 arg as the rest is ignored by cd
}






'CD more
The command cd directory changes the working directory of the current shell execution environment (see sh) to directory.

In the shell, the command cd - is a special case that changes the current working directory to the previous working directory by exchanging the values of the variables PWD and OLDPWD.

Calling cd without arguments sets the working directory to the value of the HOME environment variable, if the variable exists. If there is no HOME variable, cd does not change the working directory.

The form cd old new is an extension to the POSIX standard and optionally to the Korn shell. The shell keeps the name of the working directory in the variable PWD.

//https://www.ibm.com/docs/en/zos/2.3.0?topic=descriptions-cd-change-working-directory

Absolute and Relative Path Names #
When specifying a directory to change to, you can use either absolute or relative path names. The absolute or full path starts from the system root /, and the relative path starts from your current directory.

By default, when you log into your Linux system, your current working directory is set to your home directory. Assuming that the Downloads directory exists in your home directory, you can navigate to it by using the relative path to the directory:
"cd Downloads"
You can also navigate to the same directory by using its absolute path:

"cd /home/username/Downloads"
In short, if the path starts with a slash (/), it is the absolute path to the directory.

On Unix-like operating systems, the current working directory is represented by a single dot (.). Two dots (..), one after the other, represent the parent directory or the directory immediately above the current one.

































'Built-ins
belong to shell as part of it, does not have path. need to be written manually.


ENVIROMENTAL
//https://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html = documentation Environment Variables
//https://man7.org/linux/man-pages/man7/environ.7.html - environ

On many implementations of the C programming language and especially on POSIX, the environment is accessible from the environ global variable. You may need to declare it manually as its not declared in any standard header file:

extern char **environ;
environ points to a NULL terminated array of pointers to variable=value strings. For example, if your environment has the variables foo, bar, and baz, the entries in environ might be:

environ[0] = "foo=a";
environ[1] = "bar=b";
environ[2] = "baz=c";
environ[3] = NULL;
To alter the environment without using the setenv() or putenv() functions, check if the key you want to set already exists. If it does, overwrite the entry for that key. Else you need to copy the content of environ into a new array and add the new entry to its end. You can use malloc() or calloc() and memcpy() for this purpose. Since this is homework, I'm not going to supply further details.
//https://stackoverflow.com/questions/34300527/how-do-i-program-my-own-setenv

adding a new string at the end will not always produce the expected behavior, the OP should first scan the strings to find a potential match for the environment variable whose value needs to be set and not copy this line into the new environment array.






'ECHO
	" echo – write arguments to the standard output "

SYNOPSIS
	 echo [-n] [string ...]

DESCRIPTION
	 The echo utility writes any specified operands, separated by single blank
	 (‘ ’) characters and followed by a newline (‘\n’) character, to the
	 standard output.

	 The following option is available:

	 -n    Do not print the trailing newline character.  This may also be
		   achieved by appending ‘\c’ to the end of the string, as is done by
		   iBCS2 compatible systems.  Note that this option as well as the
		   effect of ‘\c’ are implementation-defined in IEEE Std 1003.1-2001
		   (“POSIX.1”) as amended by Cor. 1-2002.  Applications aiming for
		   maximum portability are strongly encouraged to use printf(1) to
		   suppress the newline character.

	 Some shells may provide a builtin echo command which is similar or
	 identical to this utility.  Most notably, the builtin echo in sh(1) does
	 not accept the -n option.  Consult the builtin(1) manual page.

EXIT STATUS
	 The echo utility exits 0 on success, and >0 if an error occurs.




Available functns


"readline"
//https://linux.die.net/man/3/readline
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

char *readline (const char *prompt);
"readline" will read a line from the terminal and return it, using prompt as a prompt. If prompt is NULL or the empty string, no prompt is issued. The line returned is allocated with malloc(3); the caller must free it when finished. The line returned has the final newline removed, so only the text of the line remains.

"rl_clear_history",
//https://tiswww.case.edu/php/chet/readline/readline.html
longread, enjoy
Function: void rl_clear_history (void)
Clear the history list by deleting all of the entries, in the same manner as the History librarys clear_history() function. This differs from clear_history because it frees private data Readline saves in the history list.


"rl_on_new_line"


rl_replace_line,
rl_redisplay,
add_history,
printf,
malloc,
free,
write,
access,
open,
read,
close,
fork,
wait,
waitpid,
wait3,
wait4,

//signal group
signal,
sigaction



sigemptyset,
sigaddset,
kill,
exit,
getcwd,
chdir,
stat,
lstat,
fstat,
unlink,
execve,
dup,
dup2,
pipe,
opendir,
readdir,
closedir,
strerror,
perror,
isatty,
ttyname,
ttyslot,
ioctl,
getenv,


"set of functions for terminal"
//https://linux.die.net/man/3/tcgetattr#:~:text=tcgetattr()%20gets%20the%20parameters,changed%20by%20a%20foreground%20process.&text=the%20change%20occurs%20immediately.

//https://tiswww.case.edu/php/chet/readline/readline.html#SEC53
- a lot of info for these functions

"tcsetattr",
//https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-tcsetattr-set-attributes-terminal


"tcgetattr",
tcgetattr() gets the parameters associated with the object referred by fd and stores them in the termios structure referenced by termios_p. This function may be invoked from a background process; however, the terminal attributes may be subsequently changed by a foreground process.

"tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs - direct curses interface to the terminfo capability database"

tgetent,
tgetflag,
tgetnum,
tgetstr,
tgoto,
tputs


